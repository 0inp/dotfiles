plugins=(pass)
CASE_SENSITIVE=true
ZSH_DISABLE_COMPFIX=true

ANTIGEN_PATH=$HOME/dotfiles
source $ANTIGEN_PATH/antigen/antigen.zsh
antigen init ${HOME}/.antigenrc
# Spaceships Prompt theme customization
export SPACESHIP_GCLOUD_SHOW=false

export LANG=en
export TERM='xterm-256color'
export LC_ALL=en_US.utf-8
export LC_CTYPE=en_US.utf-8
export EDITOR=vi
export PGHOST=localhost
export PACKAGECLOUD_TOKEN=5a437f5ec3db1d55e243644691ed21170b8befe2d1ed94a8
export PACKAGECLOUD_NPM_TOKEN=da74db59526ca18ce45521a27ecac7fb2ec2d98d95b1c0b7

# Customize to your needs...
alias less='less -r'
alias vi='vim'
alias tmux='tmux -2'
alias python=/usr/local/bin/python3
alias pip=/usr/local/bin/pip3
autoload -Uz compinit && compinit
bindkey '^I' complete-word

# set PATH so it includes user's private bin if it exists
if [ -d "$HOME/bin" ] ; then
    PATH="$HOME/bin:$PATH"
fi

[ -f ~/.fzf.zsh ] && source ~/.fzf.zsh
export FZF_DEFAULT_OPTS='
  --color fg:-1,bg:-1,hl:230,fg+:3,bg+:233,hl+:229
  --color info:150,prompt:110,spinner:150,pointer:167,marker:174
  --height=40%
  --preview="cat {}"
  --preview-window=right:60%:wrap
'
if command -v ag > /dev/null 2>&1; then
  export FZF_DEFAULT_COMMAND="ag -l 2> /dev/null"
  export FZF_CTRL_T_COMMAND="${FZF_DEFAULT_COMMAND}"
fi

# Load virtualenvwrapper
export WORKON_HOME=$HOME/.virtualenvs
if [ -f /usr/local/bin/virtualenvwrapper.sh ]
then
    source /usr/local/bin/virtualenvwrapper.sh
    workon
fi

if [ -f ~/.localrc ]
then
    source ~/.localrc
fi

PYTHONSTARTUP=~/.pythonrc.py
export PYTHONSTARTUP

export PATH="$HOME/.pyenv/bin:$PATH"
export PATH="$HOME/opt/pyenv/bin:$PATH"
export PYENV_ROOT="$HOME/.pyenv"
eval "$(pyenv init -)"
eval "$(pyenv virtualenv-init -)"

alias fixssh='eval $(tmux showenv -s SSH_AUTH_SOCK)'
SSH_ENV="${HOME}/.ssh/environment"

stop_ssh_agent() {
  if [[ -n ${SSH_AGENT_PID:-} ]]; then
    ssh-agent -k
    rm -rf "${SSH_ENV}"
  fi
}

init_ssh_agent() {
  printf "Initializing new SSH agent...\n"

  touch "${SSH_ENV}"
  chmod 600 "${SSH_ENV}"

  ssh-agent | sed 's/^echo/#echo/' > "${SSH_ENV}"
  source "${SSH_ENV}" > /dev/null
}

start_ssh_agent() {
  stop_ssh_agent

  if [[ -d ${HOME}/.ssh/ ]]; then
    local AGENT_INITIALIZED="false"

    for key in "${HOME}/.ssh/"*.pub; do
      if [[ ${AGENT_INITIALIZED} == "false" ]]; then
        AGENT_INITIALIZED="true"
        init_ssh_agent
      fi

      ssh-add -k "${key%.pub}"
    done
  fi
}

if [[ -f ${SSH_ENV} ]]; then
  source "${SSH_ENV}" > /dev/null
else
  start_ssh_agent
fi

compdef _pass altpass
zstyle ':completion::complete:altpass::' prefix "$HOME/my_password_store"
altpass() {
  PASSWORD_STORE_DIR=$HOME/my_password_store pass $@
}

export PATH="/usr/local/sbin:$PATH"

# The next line updates PATH for the Google Cloud SDK.
if [ -f "$HOME/opt/google-cloud-sdk/path.zsh.inc" ]; then . "$HOME/opt/google-cloud-sdk/path.zsh.inc"; fi

# The next line enables shell command completion for gcloud.
if [ -f "$HOME/opt/google-cloud-sdk/completion.zsh.inc" ]; then . "$HOME/opt/google-cloud-sdk/completion.zsh.inc"; fi

if ! command -v gcloud > /dev/null 2>&1; then
  return
fi

export BOTO_CONFIG=/dev/null
export CLOUDSDK_PYTHON=/usr/bin/python

gcloud_auth() {
  rm -rf "/tmp/${USER}*"
  gcloud auth login --no-launch-browser

  gcloud config unset compute/region
  gcloud config set project "$(gcloud projects list | grep dev | awk '{print $1}')"

  if command -v docker > /dev/null 2>&1; then
    gcloud --quiet auth configure-docker "eu.gcr.io"
  fi
}
dev_sync() {
  (
    cd "${MA_REPOSITORY}"
    watch_sync stephanep meilleursagents
  )
}
#!/usr/bin/env bash
git_is_inside() {
  git rev-parse --is-inside-work-tree 2>&1
}
git_root() {
  if [[ $(git_is_inside) != "true" ]]; then
    pwd
    return
  fi
  git rev-parse --show-toplevel
}
head_sync() {
  if [[ ${#} -ne 2 ]]; then
    printf "%bUsage: head_sync [REMOTE_SERVER] [REMOTE_PATH]%b\n" "${RED}" "${RESET}"
    return 1
  fi
  local branch
  branch="$(git symbolic-ref -q HEAD | sed -e 's|^refs/heads/||')"
  ssh -A "${1}" "cd ${2} && git reset HEAD . && git clean -f && git status -u -s | awk '{print $2}' | xargs rm -rf && git checkout -- . && git fetch && git checkout ${branch} && git pull"
}
git_sync() {
  if [[ ${#} -lt 2 ]]; then
    printf "%bUsage: git_sync [REMOTE_SERVER] [REMOTE_PATH] [DRY]?%b\n" "${RED}" "${RESET}"
    return 1
  fi
  git_root
  isGit=$?
  if [[ ${isGit} -ne 0 ]]; then
    return ${isGit}
  fi
  local REMOTE_PATH_PREFIX="~/${2}"
  if [[ ${2:0:1} == "/" ]]; then
    REMOTE_PATH_PREFIX="${2}"
  fi
  local dry=false
  if [[ $(echo "${3}" | tr "[:upper:]" "[:lower:]") == "dry" ]]; then
    dry=true
  fi
  if [[ ${dry} == true ]]; then
    printf "%bDry run of syncing files...%b\n" "${BLUE}" "${RESET}"
  else
    printf "%bSyncing files at %s...%b\n" "${BLUE}" "$(date +'%H:%M:%S')" "${RESET}"
  fi
  declare -a toSync
  declare -a toDelete
  local IFS=$'\n'
  for gitFile in $(git status --porcelain); do
    local prefix="${gitFile:0:2}"
    local trimmedPrefix="${prefix#[[:space:]]}"
    case "${trimmedPrefix:0:1}" in
      "M" | "A" | "?")
        toSync+=("${gitFile:3}")
        ;;
      "D")
        toDelete+=("${REMOTE_PATH_PREFIX}/${gitFile:3}")
        ;;
      "R")
        local originFile
        originFile="$(echo "${gitFile}" | awk '{print $2}')"
        local destinationFile
        destinationFile="$(echo "${gitFile}" | awk '{print $4}')"
        toDelete+=("${REMOTE_PATH_PREFIX}/${originFile}")
        toSync+=("${destinationFile}")
        ;;
      *)
        printf "%b¯\_(ツ)_/¯ Don't know how to handle ${gitFile}%b\n" "${BLUE}" "${RESET}"
    esac
  done
  if ! ${dry}; then
    printf "%bCleaning remote%b\n" "${YELLOW}" "${RESET}"
    ssh "${1}" "cd ${REMOTE_PATH_PREFIX} && git clean -f && git checkout -- ."
  fi
  if [[ ${#toDelete[@]} -ne 0 ]]; then
    ! ${dry} && ssh "${1}" "rm -rf ${toDelete[*]}"
    printf "%b- Deleted\n%s%b\n" "${RED}" "${toDelete[*]}" "${RESET}"
  fi
  if [[ ${#toSync[@]} -ne 0 ]]; then
    ! ${dry} && rsync -raR "${toSync[@]}" "${1}:${REMOTE_PATH_PREFIX}/"
    printf "%b+ Copied\n%s%b\n" "${GREEN}" "${toSync[*]}" "${RESET}"
  fi
  printf "%bDone at %s!%b\n\n" "${BLUE}" "$(date +'%H:%M:%S')" "${RESET}"
}
watch_sync() {
  if [[ -z ${NO_HEAD_SYNC:-} ]]; then
    head_sync "${@}"
  fi
  git_sync "${@}"
  fswatch -0 -o --exclude=.git/ . | while read -r -d ""
  do
    git_sync "${@}"
  done
}
